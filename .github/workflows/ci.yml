name: CI

on:
  push:
    branches: [ master, main ]
  pull_request:
    branches: [ master, main ]

jobs:
  unit-tests:
    runs-on: ubuntu-latest
    name: Unit Tests

    steps:
      - uses: actions/checkout@v4

      - name: Setup Perl
        uses: shogo82148/actions-setup-perl@v1
        with:
          perl-version: '5.38'

      - name: Install dependencies
        run: |
          cpanm --notest DBI DBD::Pg LWP::UserAgent JSON Test::More

      - name: Run unit tests
        run: prove -v -Ilib t/01-basic.t

  integration-tests:
    runs-on: ubuntu-latest
    name: Integration Tests

    steps:
      - uses: actions/checkout@v4

      - name: Start Patroni cluster
        working-directory: docker
        run: |
          chmod +x init-db.sh wait-for-cluster.sh
          docker compose up -d etcd patroni1 patroni2 patroni3

      - name: Wait for cluster to be ready
        working-directory: docker
        run: |
          echo "Waiting for Patroni cluster..."
          for i in {1..60}; do
            if docker compose exec -T patroni1 patronictl -c /home/postgres/postgres.yml list 2>/dev/null | grep -q "Leader"; then
              echo "Cluster is ready"
              docker compose exec -T patroni1 patronictl -c /home/postgres/postgres.yml list
              break
            fi
            echo "Attempt $i/60..."
            sleep 5
          done

      - name: Initialize test database
        working-directory: docker
        run: |
          # Find the leader and create test database
          LEADER=$(docker compose exec -T patroni1 patronictl -c /home/postgres/postgres.yml list 2>/dev/null | grep Leader | awk '{print $2}')
          echo "Leader is: $LEADER"

          # Create user and database
          docker compose exec -T $LEADER psql -U postgres -c "CREATE USER testuser WITH PASSWORD 'testpass';" || true
          docker compose exec -T $LEADER psql -U postgres -c "CREATE DATABASE testdb OWNER testuser;" || true

          # Create test tables
          docker compose exec -T $LEADER psql -U postgres -d testdb -c "
            CREATE TABLE IF NOT EXISTS users (
              id SERIAL PRIMARY KEY,
              name VARCHAR(100) NOT NULL,
              created_at TIMESTAMP DEFAULT NOW()
            );
            GRANT ALL PRIVILEGES ON TABLE users TO testuser;
            GRANT USAGE, SELECT ON SEQUENCE users_id_seq TO testuser;

            CREATE TABLE IF NOT EXISTS logs (
              id SERIAL PRIMARY KEY,
              message TEXT,
              created_at TIMESTAMP DEFAULT NOW()
            );
            GRANT ALL PRIVILEGES ON TABLE logs TO testuser;
            GRANT USAGE, SELECT ON SEQUENCE logs_id_seq TO testuser;
          "

          echo "Test database initialized"

      - name: Get cluster info
        working-directory: docker
        run: |
          docker compose exec -T patroni1 patronictl -c /home/postgres/postgres.yml list

      - name: Run integration tests in container
        working-directory: docker
        run: |
          # Run tests inside a container on the same Docker network
          docker compose run --rm -T test-runner bash -c "
            apt-get update && apt-get install -y libpq-dev curl jq >/dev/null 2>&1 &&
            cpanm --notest DBI DBD::Pg LWP::UserAgent JSON Test::More >/dev/null 2>&1 &&
            cd /app && prove -v -Ilib t/02-integration.t
          "

      - name: Cleanup
        if: always()
        working-directory: docker
        run: docker compose down -v

  failover-tests:
    if: false  # Temporarily disabled until integration tests pass
    runs-on: ubuntu-latest
    name: Failover Tests

    steps:
      - uses: actions/checkout@v4

      - name: Start Patroni cluster
        working-directory: docker
        run: |
          chmod +x init-db.sh wait-for-cluster.sh
          docker compose up -d etcd patroni1 patroni2 patroni3

      - name: Wait for cluster to be ready
        working-directory: docker
        run: |
          echo "Waiting for Patroni cluster..."
          for i in {1..60}; do
            RUNNING=$(docker compose exec -T patroni1 patronictl -c /home/postgres/postgres.yml list 2>/dev/null | grep -c "running" || echo "0")
            if [ "$RUNNING" -ge 3 ]; then
              echo "All 3 nodes are running"
              docker compose exec -T patroni1 patronictl -c /home/postgres/postgres.yml list
              break
            fi
            echo "Attempt $i/60... ($RUNNING nodes running)"
            sleep 5
          done

      - name: Wait for database initialization
        working-directory: docker
        run: |
          sleep 10
          for i in {1..30}; do
            LEADER=$(docker compose exec -T patroni1 patronictl -c /home/postgres/postgres.yml list 2>/dev/null | grep Leader | awk '{print $2}')
            if [ -n "$LEADER" ]; then
              if docker compose exec -T $LEADER psql -U postgres -c "SELECT 1 FROM pg_database WHERE datname='testdb'" 2>/dev/null | grep -q "1"; then
                echo "Database testdb is ready on $LEADER"
                break
              fi
            fi
            echo "Attempt $i/30..."
            sleep 3
          done

      - name: Run failover tests in container
        working-directory: docker
        run: |
          # Run failover tests inside a container on the same Docker network
          docker compose run --rm -T -e TEST_FAILOVER=1 test-runner bash -c "
            apt-get update && apt-get install -y libpq-dev curl jq >/dev/null 2>&1 &&
            cpanm --notest DBI DBD::Pg LWP::UserAgent JSON Test::More >/dev/null 2>&1 &&
            cd /app && prove -v -Ilib t/03-failover.t
          "

      - name: Show cluster state after tests
        if: always()
        working-directory: docker
        run: |
          docker compose exec -T patroni1 patronictl -c /home/postgres/postgres.yml list || true

      - name: Cleanup
        if: always()
        working-directory: docker
        run: docker compose down -v
